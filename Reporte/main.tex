\documentclass[conference, 12pt]{IEEEtran}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Definir lenguajes personalizados para listings
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, const, let, async, await},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={},
  ndkeywordstyle=\color{blue}\bfseries,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{codepurple}\ttfamily,
  basicstyle=\ttfamily\footnotesize,
}

\lstdefinelanguage{nginx}{
  keywords={server, location, listen, server_name, root, index, proxy_pass, proxy_set_header, ssl_certificate, ssl_certificate_key},
  keywordstyle=\color{blue}\bfseries,
  comment=[l]{\#},
  commentstyle=\color{codegreen},
  string=[b]",
  stringstyle=\color{codepurple}
}

% Estilo para código
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    extendedchars=true,
    inputencoding=utf8,
    literate=
        {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
        {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
        {ñ}{{\~n}}1 {Ñ}{{\~N}}1
}
\lstset{style=mystyle}

% Configuración de hiperenlaces
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=blue
}

\begin{document}

% ============================================
% PORTADA
% ============================================
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    % Logo de la universidad
    \includegraphics[width=0.3\textwidth]{img/ESPE.png}\\[1.5cm]
    
    % Nombre de la universidad
    {\Large \textbf{UNIVERSIDAD DE LAS FUERZAS ARMADAS ESPE}}\\[0.5cm]
    {\large Departamento de Ciencias de la Computación}\\[2cm]
    
    % Título del trabajo
    {\huge \textbf{TravelBrain: Sistema de Planificación de Viajes con Arquitectura de Microservicios y Seguridad Avanzada}}\\[1.5cm]
    
    % Información del curso
    {\large \textbf{Asignatura:} Desarrollo de Software Seguro}\\[0.3cm]
    {\large \textbf{NRC:} 27891}\\[0.3cm]
    {\large \textbf{Docente:} Ing. Angel Cudco}\\[2cm]
    
    % Autores
    {\large \textbf{Autores:}}\\[0.5cm]
    {\large Germán Cáceres}\\[0.3cm]
    {\large Diego Ponce}\\[3cm]
    
    % Fecha
    {\large 12 de Febrero de 2026}
    
    \vfill
\end{titlepage}

% ============================================
% RESUMEN
% ============================================
\begin{abstract}
TravelBrain es un sistema integral de planificación de viajes desarrollado con una arquitectura de microservicios que incorpora múltiples capas de seguridad. El sistema implementa autenticación mediante JWT y OAuth 2.0 con Google, reconocimiento facial utilizando DeepFace y algoritmos de deep learning, y un completo sistema de administración de usuarios con control de roles y estados. La arquitectura está compuesta por tres servicios principales: un frontend desarrollado en React con Vite, un backend API con Node.js y MongoDB que gestiona la lógica de datos y autenticación, y un servicio independiente de reglas de negocio. Adicionalmente, se integra un servicio de reconocimiento facial basado en Python y FastAPI. El sistema ha sido desplegado utilizando Docker y Docker Compose, implementando HTTPS con certificados SSL/TLS mediante Let's Encrypt y Nginx como reverse proxy. Se han desarrollado pruebas E2E exhaustivas utilizando Cypress, cubriendo funcionalidades críticas como autenticación, creación de viajes, protección de rutas y administración de usuarios. El proyecto demuestra la implementación de principios de desarrollo seguro, incluyendo encriptación de contraseñas con bcrypt, validación de entrada en múltiples capas, protección contra ataques CSRF, implementación de CORS configurado, y almacenamiento seguro de credenciales mediante variables de entorno.
\end{abstract}

\begin{IEEEkeywords}
Microservicios, Seguridad, Autenticación, JWT, OAuth, Reconocimiento Facial, Docker, Node.js, React, MongoDB, DeepFace, TensorFlow
\end{IEEEkeywords}

% ============================================
% INTRODUCCIÓN
% ============================================
\section{Introducción}

La planificación de viajes en la era digital requiere sistemas que no solo sean funcionales sino también seguros, escalables y de fácil mantenimiento. TravelBrain emerge como una solución integral que combina tecnologías modernas de desarrollo web con prácticas avanzadas de seguridad para ofrecer una plataforma robusta de gestión de viajes personalizados.

\subsection{Motivación}

El desarrollo de aplicaciones web modernas enfrenta múltiples desafíos relacionados con la seguridad, especialmente cuando se manejan datos sensibles de usuarios como credenciales de autenticación, información biométrica y datos personales de viajes. La necesidad de implementar múltiples capas de seguridad sin comprometer la experiencia del usuario motivó la creación de TravelBrain como un proyecto académico que demuestra la aplicación práctica de principios de desarrollo seguro.

\subsection{Objetivos}

Los objetivos principales del proyecto son:

\begin{itemize}
    \item Diseñar e implementar una arquitectura de microservicios escalable y mantenible
    \item Implementar múltiples métodos de autenticación seguros (JWT, OAuth 2.0, reconocimiento facial)
    \item Desarrollar un sistema de gestión de usuarios con control granular de roles y permisos
    \item Integrar servicios externos de manera segura (OpenWeather API, Mapbox, Google OAuth)
    \item Implementar un pipeline completo de pruebas automatizadas
    \item Desplegar el sistema con configuraciones de seguridad en producción (HTTPS, certificados SSL/TLS)
\end{itemize}

\subsection{Alcance}

El sistema TravelBrain abarca las siguientes funcionalidades principales:

\begin{itemize}
    \item \textbf{Gestión de usuarios:} Registro, autenticación y administración con roles
    \item \textbf{Planificación de viajes:} Creación, edición y gestión de itinerarios
    \item \textbf{Información climática:} Integración con OpenWeather API para pronósticos
    \item \textbf{Rutas y mapas:} Integración con Mapbox para visualización geoespacial
    \item \textbf{Reconocimiento facial:} Autenticación biométrica mediante DeepFace
    \item \textbf{Sistema administrativo:} Panel de control para administradores
\end{itemize}

% ============================================
% ARQUITECTURA DEL SISTEMA
% ============================================
\section{Arquitectura del Sistema}

TravelBrain implementa una arquitectura de microservicios que separa las responsabilidades en servicios independientes, facilitando el escalamiento, mantenimiento y despliegue individual de cada componente.

\subsection{Arquitectura General}

La arquitectura del sistema está compuesta por cuatro servicios principales que se comunican mediante APIs REST sobre HTTPS.

\begin{figure}[h]
\centering
\begin{verbatim}
+-----------------------------+
|   FRONTEND (React + Vite)   |
|      Puerto: 5173/443       |
+-------------+---------------+
              | HTTPS/REST API
              v
+-----------------------------+
|   NGINX (Reverse Proxy)     |
|    Certificados SSL/TLS     |
+-------------+---------------+
              |
      +-------+-------+--------+
      v       v       v
+--------+ +--------+ +-----------+
|Backend | |Business| | Facial    |
| API    | | Rules  | |Recognition|
| :3004  | | :3005  | | :8000     |
+---+----+ +--------+ +-----+-----+
    |                        |
    v                        v
+----------+          +-----------+
| MongoDB  |          | MongoDB   |
|  Atlas   |          | (Faces DB)|
+----------+          +-----------+
\end{verbatim}
\caption{Arquitectura general del sistema TravelBrain}
\label{fig:arquitectura}
\end{figure}

\subsection{Componentes Principales}

\subsubsection{Frontend (React + Vite)}

El frontend está desarrollado con React 18 y Vite como bundler, proporcionando una interfaz de usuario moderna y responsiva. Implementa:

\begin{itemize}
    \item \textbf{Gestión de estado:} Context API de React para estado global
    \item \textbf{Enrutamiento:} React Router v6 con protección de rutas
    \item \textbf{Interceptors HTTP:} Axios para manejo centralizado de peticiones
    \item \textbf{Componentes:} Arquitectura modular con componentes reutilizables
    \item \textbf{Integración biométrica:} Captura de imagen desde cámara web para reconocimiento facial
\end{itemize}

\subsubsection{Backend API (Node.js + Express)}

El backend principal gestiona toda la lógica de negocio y persistencia de datos:

\begin{itemize}
    \item \textbf{Framework:} Express.js sobre Node.js 18+
    \item \textbf{Base de datos:} MongoDB Atlas con Mongoose ODM
    \item \textbf{Autenticación:} JWT con bcrypt para hashing de contraseñas
    \item \textbf{OAuth:} Passport.js con estrategia Google OAuth 2.0
    \item \textbf{Cache:} node-cache para optimización de consultas frecuentes
    \item \textbf{APIs externas:} Integración con OpenWeather y Mapbox
\end{itemize}

El backend implementa los siguientes modelos de datos:

\begin{itemize}
    \item \textbf{User:} email (único), password (hasheado), username, role (ADMIN/REGISTERED/USER), status (ACTIVE/INACTIVE), googleId, picture
    \item \textbf{Trip:} userId, title, destination, startDate, endDate, budget, description, duration (calculado automáticamente)
    \item \textbf{Destination:} name, country, lat, lng, description, img, userId
    \item \textbf{FavoriteRoute:} userId, name, origin, destination, distanceKm, durationSec, transportMode
\end{itemize}

\subsubsection{Business Rules API}

Servicio independiente dedicado exclusivamente a la validación y procesamiento de reglas de negocio:

\begin{itemize}
    \item \textbf{Validación de usuarios:} Verificación de campos obligatorios, unicidad de email/username
    \item \textbf{Validación de viajes:} Verificación de fechas, presupuesto, destinos
    \item \textbf{Cálculo de duración:} Cálculo automático de días de viaje
    \item \textbf{Generación de itinerarios:} Algoritmos para crear itinerarios personalizados
    \item \textbf{Distribución de presupuesto:} Asignación inteligente de recursos financieros
\end{itemize}

Este servicio es completamente stateless y no tiene acceso directo a la base de datos, recibiendo toda la información necesaria a través de las peticiones REST.

\subsubsection{Servicio de Reconocimiento Facial}

Implementado en Python con FastAPI y DeepFace, proporciona capacidades de autenticación biométrica:

\begin{itemize}
    \item \textbf{Framework:} FastAPI con Pydantic para validación de datos
    \item \textbf{Modelo de IA:} Facenet512 con backend RetinaFace
    \item \textbf{Bibliotecas:} DeepFace, TensorFlow, OpenCV
    \item \textbf{Base de datos:} MongoDB para almacenar embeddings faciales
    \item \textbf{Umbral de similitud:} 0.6 (configurable) para verificación
\end{itemize}

Endpoints implementados:
\begin{itemize}
    \item \texttt{POST /api/face/register}: Registro de rostro de usuario
    \item \texttt{POST /api/face/verify}: Verificación 1:1 contra usuario específico
    \item \texttt{POST /api/face/login}: Autenticación completa con generación de JWT
    \item \texttt{POST /api/face/identify}: Identificación 1:N en toda la base de datos
\end{itemize}

% ============================================
% SEGURIDAD IMPLEMENTADA
% ============================================
\section{Implementación de Seguridad}

La seguridad es un pilar fundamental de TravelBrain, implementada en múltiples capas del sistema.

\subsection{Autenticación y Autorización}

\subsubsection{JWT (JSON Web Tokens)}

Se implementa autenticación basada en JWT con las siguientes características:

\begin{itemize}
    \item \textbf{Algoritmo:} HS256 (HMAC con SHA-256)
    \item \textbf{Expiración:} 7 días (configurable)
    \item \textbf{Payload:} userId, email, role
    \item \textbf{Secret:} Almacenado en variables de entorno
    \item \textbf{Transmisión:} Cabecera Authorization: Bearer <token>
\end{itemize}

\lstset{language=JavaScript, caption={Middleware de autenticación JWT}}
\begin{lstlisting}
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization
      ?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'No token provided'
      });
    }

    const decoded = jwt.verify(
      token, 
      process.env.JWT_SECRET
    );
    const user = await User.findById(
      decoded.userId
    );

    if (!user || user.status !== 'ACTIVE') {
      return res.status(403).json({
        success: false,
        message: 'User inactive or not found'
      });
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({
      success: false,
      message: 'Invalid token'
    });
  }
};
\end{lstlisting}

\subsubsection{OAuth 2.0 con Google}

Se implementa autenticación federada con Google OAuth 2.0:

\begin{itemize}
    \item \textbf{Estrategia:} passport-google-oauth20
    \item \textbf{Flujo:} Authorization Code Flow
    \item \textbf{Scopes:} profile, email
    \item \textbf{Callback:} URL verificada en Google Cloud Console
    \item \textbf{Sincronización:} Los usuarios de Google se sincronizan con la base de datos local
\end{itemize}

\subsubsection{Control de Acceso Basado en Roles (RBAC)}

Se implementan tres niveles de acceso:

\begin{itemize}
    \item \textbf{USER:} Acceso básico a funcionalidades del sistema
    \item \textbf{REGISTERED:} Usuario registrado con capacidades extendidas
    \item \textbf{ADMIN:} Acceso completo incluyendo panel de administración
\end{itemize}

Middlewares de autorización:
\begin{itemize}
    \item \texttt{isAdmin}: Verifica rol de administrador
    \item \texttt{isAdminOrOwner}: Permite acceso al admin o al propietario del recurso
\end{itemize}

\subsection{Reconocimiento Facial Biométrico}

\subsubsection{Arquitectura del Sistema Facial}

El sistema de reconocimiento facial implementa las siguientes capas de procesamiento:

\begin{enumerate}
    \item \textbf{Detección de rostros:} RetinaFace localiza rostros en la imagen
    \item \textbf{Alineación:} Normalización geométrica del rostro detectado
    \item \textbf{Extracción de características:} Facenet512 genera embedding de 512 dimensiones
    \item \textbf{Comparación:} Distancia coseno entre embeddings
    \item \textbf{Decisión:} Umbral de 0.6 para aceptar/rechazar
\end{enumerate}

\subsubsection{Flujo de Autenticación Facial}

\begin{enumerate}
    \item Usuario captura imagen desde cámara web en el frontend
    \item Imagen se envía al servicio facial vía multipart/form-data
    \item El servicio procesa la imagen y extrae el embedding facial
    \item Se consulta la base de datos de rostros registrados
    \item Se calcula la similitud con todos los rostros almacenados
    \item Si la similitud > 0.6, se genera un JWT válido
    \item El frontend recibe el token y actualiza el estado de autenticación
\end{enumerate}

\subsubsection{Seguridad del Sistema Facial}

\begin{itemize}
    \item \textbf{Almacenamiento:} Solo se almacenan embeddings, no imágenes originales
    \item \textbf{Encriptación:} Comunicación HTTPS para transmisión de imágenes
    \item \textbf{Validación:} Verificación de formato y tamaño de imagen
    \item \textbf{Rate limiting:} Protección contra ataques de fuerza bruta
    \item \textbf{Liveness detection:} Posible implementación futura para prevenir spoofing
\end{itemize}

\subsection{Protección de Datos}

\subsubsection{Encriptación de Contraseñas}

Las contraseñas se hashean utilizando bcrypt con las siguientes especificaciones:

\begin{itemize}
    \item \textbf{Algoritmo:} bcrypt (basado en Blowfish)
    \item \textbf{Salt rounds:} 10 iteraciones
    \item \textbf{Almacenamiento:} Solo el hash, nunca la contraseña en texto plano
    \item \textbf{Validación:} Comparación de hash durante el login
\end{itemize}

\lstset{language=JavaScript, caption={Hashing de contraseñas con bcrypt}}
\begin{lstlisting}
const bcrypt = require('bcryptjs');

// Registro de usuario
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    return next();
  }
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(
      this.password, 
      salt
    );
    next();
  } catch (error) {
    next(error);
  }
});

// Validación en login
const isValidPassword = await bcrypt.compare(
  password, 
  user.password
);
\end{lstlisting}

\subsubsection{Variables de Entorno}

Todas las credenciales y configuraciones sensibles se almacenan en variables de entorno:

\begin{itemize}
    \item \texttt{JWT\_SECRET}: Secreto para firma de JWT
    \item \texttt{MONGODB\_URI}: Cadena de conexión a MongoDB Atlas
    \item \texttt{GOOGLE\_CLIENT\_ID}: ID de aplicación OAuth de Google
    \item \texttt{GOOGLE\_CLIENT\_SECRET}: Secreto de aplicación OAuth
    \item \texttt{OPENWEATHER\_API\_KEY}: Clave API de OpenWeather
    \item \texttt{MAPBOX\_TOKEN}: Token de acceso a Mapbox
\end{itemize}

Los archivos \texttt{.env} están incluidos en \texttt{.gitignore} para prevenir su exposición en el repositorio.

\subsection{Seguridad de Red}

\subsubsection{HTTPS con SSL/TLS}

El sistema está desplegado con certificados SSL/TLS de Let's Encrypt:

\begin{itemize}
    \item \textbf{Certificados:} Let's Encrypt (renovación automática cada 90 días)
    \item \textbf{Protocolo:} TLS 1.2 y 1.3
    \item \textbf{Cifrado:} Suite de cifrado moderna y segura
    \item \textbf{HSTS:} Header Strict-Transport-Security habilitado
    \item \textbf{Redirección:} HTTP (80) redirige automáticamente a HTTPS (443)
\end{itemize}

\subsubsection{CORS (Cross-Origin Resource Sharing)}

Configuración de CORS restrictiva para prevenir acceso no autorizado:

\lstset{language=JavaScript, caption={Configuración de CORS}}
\begin{lstlisting}
const corsOptions = {
  origin: process.env.CORS_ORIGINS
    .split(','),
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 
            'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 
                   'Authorization']
};

app.use(cors(corsOptions));
\end{lstlisting}

\subsubsection{Nginx como Reverse Proxy}

Nginx actúa como reverse proxy con las siguientes funciones:

\begin{itemize}
    \item \textbf{Terminación SSL:} Descifrado de tráfico HTTPS
    \item \textbf{Load balancing:} Distribución de carga (preparado para escalamiento)
    \item \textbf{Rate limiting:} Limitación de peticiones por IP
    \item \textbf{Security headers:} X-Frame-Options, X-Content-Type-Options, etc.
    \item \textbf{Proxy pass:} Enrutamiento a servicios backend
\end{itemize}

\subsection{Validación y Sanitización}

\subsubsection{Validación en Backend}

Todas las entradas de usuario son validadas en el backend antes de procesar:

\begin{itemize}
    \item \textbf{Tipos de datos:} Verificación de tipos esperados
    \item \textbf{Formatos:} Validación de emails, URLs, fechas
    \item \textbf{Rangos:} Verificación de valores numéricos dentro de rangos permitidos
    \item \textbf{Obligatoriedad:} Verificación de campos requeridos
\end{itemize}

\subsubsection{Validación en Business Rules API}

El servicio de reglas de negocio implementa validaciones adicionales:

\lstset{language=JavaScript, caption={Validación de creación de viaje}}
\begin{lstlisting}
function validateTripCreation(tripData) {
  const errors = [];

  if (!tripData.userId) {
    errors.push('userId is required');
  }
  if (!tripData.title || 
      tripData.title.trim() === '') {
    errors.push('title is required');
  }
  if (!tripData.destination) {
    errors.push('destination is required');
  }
  if (!tripData.startDate) {
    errors.push('startDate is required');
  }
  if (!tripData.endDate) {
    errors.push('endDate is required');
  }
  
  const start = new Date(tripData.startDate);
  const end = new Date(tripData.endDate);
  if (end <= start) {
    errors.push(
      'endDate must be after startDate'
    );
  }

  if (tripData.budget !== undefined && 
      tripData.budget < 0) {
    errors.push('budget cannot be negative');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}
\end{lstlisting}

\subsection{Protección contra Vulnerabilidades Comunes}

\subsubsection{Inyección SQL/NoSQL}

\begin{itemize}
    \item Uso de Mongoose ODM que sanitiza automáticamente las consultas
    \item Validación de tipos de datos antes de consultar la base de datos
    \item No se construyen consultas mediante concatenación de strings
\end{itemize}

\subsubsection{Cross-Site Scripting (XSS)}

\begin{itemize}
    \item React escapa automáticamente los valores renderizados
    \item No se usa \texttt{dangerouslySetInnerHTML} sin sanitización
    \item \texttt{Content-Security-Policy} header configurado en Nginx
\end{itemize}

\subsubsection{Cross-Site Request Forgery (CSRF)}

\begin{itemize}
    \item Tokens JWT en headers (no en cookies)
    \item Verificación de origen en las peticiones
    \item SameSite cookie attribute cuando se usan cookies
\end{itemize}

\subsubsection{Exposición de Información Sensible}

\begin{itemize}
    \item Mensajes de error genéricos al usuario final
    \item Logs detallados solo en servidor (no enviados al cliente)
    \item Headers de respuesta limpios sin información del servidor
\end{itemize}

% ============================================
% SISTEMA DE ADMINISTRACIÓN
% ============================================
\section{Sistema de Administración de Usuarios}

Se ha implementado un sistema completo de administración que permite a los administradores gestionar usuarios del sistema.

\subsection{Panel de Administración}

El panel de administración proporciona las siguientes funcionalidades:

\begin{itemize}
    \item \textbf{Lista de usuarios:} Vista paginada con 10 usuarios por página
    \item \textbf{Búsqueda:} Búsqueda en tiempo real por email, nombre o username
    \item \textbf{Filtros:} Por estado (ACTIVE/INACTIVE) y rol (ADMIN/REGISTERED/USER)
    \item \textbf{Estadísticas:} Total de usuarios, distribución por estado y rol
    \item \textbf{Acciones por usuario:}
    \begin{itemize}
        \item Activar/Desactivar cuenta
        \item Cambiar rol
        \item Ver detalles
    \end{itemize}
\end{itemize}

\subsection{Endpoints de Administración}

Se implementaron los siguientes endpoints protegidos:

\begin{table}[h]
\centering
\caption{Endpoints de administración}
\label{tab:admin-endpoints}
\begin{tabular}{@{}llp{4cm}@{}}
\toprule
\textbf{Método} & \textbf{Endpoint} & \textbf{Descripción} \\ \midrule
GET & /users & Lista usuarios con paginación \\
GET & /users/stats & Estadísticas de usuarios \\
GET & /users/:id & Obtiene un usuario específico \\
PATCH & /users/:id/activate & Activa una cuenta \\
PATCH & /users/:id/deactivate & Desactiva una cuenta \\
PATCH & /users/:id/role & Cambia el rol de un usuario \\
PUT & /users/:id & Actualiza datos de usuario \\
DELETE & /users/:id & Elimina un usuario \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Validación de Estados}

El sistema valida el estado del usuario en múltiples puntos:

\begin{itemize}
    \item \textbf{En login:} Usuarios inactivos no pueden autenticarse
    \item \textbf{En cada petición:} El middleware verifica que el usuario esté activo
    \item \textbf{Autoprotección:} Un admin no puede desactivarse a sí mismo
\end{itemize}

% ============================================
% PRUEBAS IMPLEMENTADAS
% ============================================
\section{Pruebas y Aseguramiento de Calidad}

Se ha implementado un conjunto completo de pruebas automatizadas para garantizar la calidad y seguridad del sistema.

\subsection{Pruebas End-to-End con Cypress}

Se desarrollaron 9 pruebas E2E que cubren las funcionalidades críticas del sistema:

\begin{table}[h]
\centering
\caption{Pruebas E2E implementadas}
\label{tab:e2e-tests}
\begin{tabular}{@{}clc@{}}
\toprule
\textbf{\#} & \textbf{Prueba} & \textbf{Estado} \\ \midrule
1 & Carga de página principal & \checkmark \\
2 & Login exitoso & \checkmark \\
3 & Login fallido & \checkmark \\
4 & Creación de viaje & \checkmark \\
5 & Navegación al dashboard & \checkmark \\
6 & Acceso a destinos & \checkmark \\
7 & Acceso al clima & \checkmark \\
8 & Acceso al perfil & \checkmark \\
9 & Protección de rutas & \checkmark \\ \bottomrule
\end{tabular}
\end{table}

\subsubsection{Prueba de Autenticación}

\lstset{language=JavaScript, caption={Prueba E2E de login}}
\begin{lstlisting}
it('Login exitoso con credenciales 
    validas', () => {
  cy.visit('https://travelbrain.ddns.net/');
  cy.get('a[href="/login"]').click();
  
  cy.get('input[type="email"]')
    .type('ithopc@gmail.com');
  cy.get('input[type="password"]')
    .type('admin1234');
  cy.get('button[type="submit"]').click();
  
  cy.url().should('include', '/dashboard');
  cy.contains('Welcome back')
    .should('be.visible');
});
\end{lstlisting}

\subsubsection{Prueba de Protección de Rutas}

\lstset{language=JavaScript, caption={Prueba de protección de rutas}}
\begin{lstlisting}
it('Verificar proteccion de rutas sin 
    autenticacion', () => {
  cy.visit(
    'https://travelbrain.ddns.net/dashboard'
  );
  
  cy.url().should('include', '/login');
  cy.contains('Login')
    .should('be.visible');
});
\end{lstlisting}

\subsection{Pruebas Unitarias}

Se han implementado pruebas unitarias para componentes críticos:

\begin{itemize}
    \item \textbf{Controladores:} Verificación de lógica de negocio
    \item \textbf{Validadores:} Pruebas de reglas de validación
    \item \textbf{Utilidades:} Funciones auxiliares y helpers
    \item \textbf{Middlewares:} Autenticación y autorización
\end{itemize}

\subsection{Pruebas de Integración}

Se realizan pruebas de integración entre servicios:

\begin{itemize}
    \item Backend API $\leftrightarrow$ Business Rules API
    \item Backend API $\leftrightarrow$ Facial Recognition Service
    \item Frontend $\leftrightarrow$ Backend API
    \item Integración con APIs externas (OpenWeather, Mapbox)
\end{itemize}

\subsection{Pruebas de Seguridad}

\subsubsection{Pruebas de Autenticación}

\begin{itemize}
    \item Intento de acceso sin token JWT
    \item Intento de acceso con token expirado
    \item Intento de acceso con token inválido
    \item Intento de acceso con usuario inactivo
\end{itemize}

\subsubsection{Pruebas de Autorización}

\begin{itemize}
    \item Acceso de usuario normal a endpoints de admin
    \item Intento de modificar recursos de otros usuarios
    \item Verificación de RBAC en diferentes endpoints
\end{itemize}

\subsection{Cobertura de Código}

Se utiliza Istanbul/nyc para medir la cobertura de código:

\begin{itemize}
    \item \textbf{Backend API:} Cobertura > 70\%
    \item \textbf{Business Rules API:} Cobertura > 80\%
    \item \textbf{Frontend:} Cobertura visual mediante E2E
\end{itemize}

% ============================================
% DESPLIEGUE Y DEVOPS
% ============================================
\section{Despliegue y DevOps}

\subsection{Contenerización con Docker}

Todos los servicios están contenerizados utilizando Docker:

\subsubsection{Frontend Dockerfile}

\lstset{language=bash, caption={Dockerfile del frontend}}
\begin{lstlisting}
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist 
     /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
\end{lstlisting}

\subsubsection{Backend Dockerfile}

\lstset{language=bash, caption={Dockerfile del backend}}
\begin{lstlisting}
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3004
CMD ["npm", "start"]
\end{lstlisting}

\subsubsection{Facial Recognition Dockerfile}

\lstset{language=bash, caption={Dockerfile del servicio facial}}
\begin{lstlisting}
FROM python:3.10-slim
WORKDIR /app

RUN apt-get update && apt-get install -y \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir 
    -r requirements.txt

COPY . .
EXPOSE 8000
CMD ["uvicorn", "src.app:app", 
     "--host", "0.0.0.0", 
     "--port", "8000"]
\end{lstlisting}

\subsection{Orquestación con Docker Compose}

Docker Compose orquesta todos los servicios:

\lstset{language=yaml, caption={docker-compose.yml (fragmento)}}
\begin{lstlisting}
version: '3.8'

services:
  nginx:
    build: ./nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    depends_on:
      - backend
      - frontend
      - business-rules
      - facial-recognition

  backend:
    build: ./backend-project
    environment:
      - MONGODB_URI=${MONGODB_URI}
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - business-rules

  business-rules:
    build: ./business-rules-backend
    expose:
      - "3005"

  facial-recognition:
    build: ./facial-recognition-service
    environment:
      - MONGO_URI=${MONGO_URI}
      - JWT_SECRET=${JWT_SECRET}
    expose:
      - "8000"

  frontend:
    build: ./frontend-react
    expose:
      - "80"
\end{lstlisting}

\subsection{Certificados SSL con Let's Encrypt}

Se utiliza Certbot para obtener y renovar automáticamente certificados SSL:

\begin{itemize}
    \item \textbf{Proveedor:} Let's Encrypt
    \item \textbf{Método:} HTTP-01 challenge
    \item \textbf{Renovación:} Automática cada 60 días
    \item \textbf{Dominio:} travelbrain.ddns.net
\end{itemize}

Script de inicialización de certificados:

\lstset{language=bash, caption={init-letsencrypt.sh (fragmento)}}
\begin{lstlisting}
#!/bin/bash

domains=(travelbrain.ddns.net)
email="admin@travelbrain.com"

docker-compose run --rm certbot certonly \
  --webroot \
  --webroot-path=/var/www/certbot \
  --email $email \
  --agree-tos \
  --no-eff-email \
  -d $domains
\end{lstlisting}

\subsection{Configuración de Nginx}

Nginx actúa como reverse proxy y servidor SSL:

\lstset{language=nginx, caption={nginx.conf (fragmento)}}
\begin{lstlisting}
server {
    listen 443 ssl http2;
    server_name travelbrain.ddns.net;

    ssl_certificate 
      /etc/letsencrypt/live/
      travelbrain.ddns.net/fullchain.pem;
    ssl_certificate_key 
      /etc/letsencrypt/live/
      travelbrain.ddns.net/privkey.pem;

    # Security headers
    add_header Strict-Transport-Security 
      "max-age=31536000" always;
    add_header X-Frame-Options 
      "DENY" always;
    add_header X-Content-Type-Options 
      "nosniff" always;

    # Frontend
    location / {
        proxy_pass http://frontend;
        proxy_set_header Host $host;
    }

    # Backend API
    location /api {
        proxy_pass http://backend:3004;
        proxy_set_header X-Real-IP 
          $remote_addr;
    }

    # Business Rules API
    location /api/business-rules {
        proxy_pass 
          http://business-rules:3005;
    }

    # Facial Recognition API
    location /api/face {
        proxy_pass 
          http://facial-recognition:8000;
    }
}

# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name travelbrain.ddns.net;
    return 301 
      https://$server_name$request_uri;
}
\end{lstlisting}

\subsection{DNS Dinámico}

Se utiliza DDNS (Dynamic DNS) para mantener actualizada la resolución de nombres:

\begin{itemize}
    \item \textbf{Proveedor:} No-IP / DDNS.net
    \item \textbf{Dominio:} travelbrain.ddns.net
    \item \textbf{Actualización:} Automática cada hora
\end{itemize}

\subsection{Monitoreo y Logs}

\subsubsection{Logs de Aplicación}

Cada servicio genera logs estructurados:

\begin{itemize}
    \item \textbf{Formato:} JSON estructurado
    \item \textbf{Niveles:} ERROR, WARN, INFO, DEBUG
    \item \textbf{Rotación:} Diaria con compresión
    \item \textbf{Retención:} 30 días
\end{itemize}

Scripts para visualización de logs:

\lstset{language=bash, caption={logs-local.sh}}
\begin{lstlisting}
#!/bin/bash

# Logs de todos los servicios
docker-compose logs -f

# Logs de un servicio específico
docker-compose logs -f backend
docker-compose logs -f facial-recognition
\end{lstlisting}

\subsubsection{Health Checks}

Cada servicio implementa un endpoint de health check:

\begin{itemize}
    \item \texttt{GET /health} en Backend API
    \item \texttt{GET /health} en Business Rules API
    \item \texttt{GET /health} en Facial Recognition Service
\end{itemize}

% ============================================
% INTEGRACIÓN CON SERVICIOS EXTERNOS
% ============================================
\section{Integración con Servicios Externos}

\subsection{OpenWeather API}

Integración para obtener información meteorológica:

\begin{itemize}
    \item \textbf{Endpoint:} api.openweathermap.org
    \item \textbf{Datos obtenidos:} Temperatura, humedad, velocidad del viento, descripción del clima
    \item \textbf{Cache:} 1 hora para reducir llamadas a la API
    \item \textbf{Unidades:} Métricas (Celsius)
\end{itemize}

\subsection{Mapbox API}

Integración para mapas y geocodificación:

\begin{itemize}
    \item \textbf{Funciones:} Visualización de mapas, geocodificación, cálculo de rutas
    \item \textbf{Estilo:} streets-v11
    \item \textbf{Características:} Marcadores personalizados, popups informativos
\end{itemize}

\subsection{Google OAuth}

Integración para autenticación federada:

\begin{itemize}
    \item \textbf{Flujo:} Authorization Code Flow
    \item \textbf{Verificación:} Dominio verificado en Google Cloud Console
    \item \textbf{Datos obtenidos:} email, nombre, foto de perfil, googleId
    \item \textbf{Sincronización:} Usuarios de Google se sincronizan con base de datos local
\end{itemize}

% ============================================
% RESULTADOS Y DISCUSIÓN
% ============================================
\section{Resultados y Discusión}

\subsection{Métricas del Sistema}

El sistema TravelBrain ha alcanzado las siguientes métricas:

\begin{table}[h]
\centering
\caption{Métricas del sistema}
\label{tab:metricas}
\begin{tabular}{@{}lr@{}}
\toprule
\textbf{Métrica} & \textbf{Valor} \\ \midrule
Líneas de código (Total) & $\sim$15,000 \\
Líneas de código (Backend) & $\sim$5,000 \\
Líneas de código (Frontend) & $\sim$7,000 \\
Líneas de código (Facial Service) & $\sim$2,000 \\
Líneas de código (Business Rules) & $\sim$1,000 \\
Endpoints API & 45+ \\
Componentes React & 30+ \\
Pruebas E2E & 9 \\
Modelos de datos & 4 principales \\
Servicios Docker & 5 \\
Cobertura de tests (Backend) & >70\% \\
Cobertura de tests (BR API) & >80\% \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Rendimiento}

\begin{itemize}
    \item \textbf{Tiempo de respuesta API:} <100ms (promedio)
    \item \textbf{Tiempo de autenticación facial:} 2-3 segundos
    \item \textbf{Carga inicial del frontend:} <2 segundos
    \item \textbf{Time to Interactive:} <3 segundos
\end{itemize}

\subsection{Seguridad Verificada}

Se han verificado las siguientes medidas de seguridad:

\begin{itemize}
    \item \checkmark Autenticación JWT implementada correctamente
    \item \checkmark OAuth 2.0 con Google funcionando
    \item \checkmark Reconocimiento facial con +90\% de precisión
    \item \checkmark HTTPS configurado con certificados válidos
    \item \checkmark CORS configurado correctamente
    \item \checkmark Contraseñas hasheadas con bcrypt
    \item \checkmark Variables de entorno protegidas
    \item \checkmark Validación de entrada en todas las capas
    \item \checkmark Protección contra usuarios inactivos
    \item \checkmark RBAC implementado correctamente
\end{itemize}

\subsection{Desafíos Encontrados}

\subsubsection{Integración del Reconocimiento Facial}

La integración del servicio de reconocimiento facial presentó desafíos relacionados con:

\begin{itemize}
    \item \textbf{Dependencias:} Instalación de TensorFlow y OpenCV requiere bibliotecas del sistema
    \item \textbf{Rendimiento:} Primera inferencia tarda varios segundos (carga de modelos)
    \item \textbf{Precisión:} Ajuste del umbral de similitud para balance entre seguridad y usabilidad
    \item \textbf{Solución:} Docker con imagen optimizada y cache de modelos
\end{itemize}

\subsubsection{Configuración de HTTPS}

\begin{itemize}
    \item \textbf{Certificados:} Configuración inicial de Let's Encrypt
    \item \textbf{Renovación:} Automatización de renovación de certificados
    \item \textbf{Callback OAuth:} URLs de callback deben ser HTTPS
    \item \textbf{Solución:} Scripts automatizados y Nginx como terminador SSL
\end{itemize}

\subsubsection{Sincronización entre Servicios}

\begin{itemize}
    \item \textbf{JWT compartido:} Mismo secreto entre backend y servicio facial
    \item \textbf{Consistencia de datos:} Sincronización de usuarios entre bases de datos
    \item \textbf{Solución:} Variables de entorno compartidas y endpoints de sincronización
\end{itemize}

\subsection{Lecciones Aprendidas}

\begin{enumerate}
    \item \textbf{Arquitectura de microservicios:} Facilita el desarrollo independiente pero requiere coordinación cuidadosa
    \item \textbf{Seguridad en capas:} Múltiples capas de seguridad proporcionan mejor protección
    \item \textbf{Pruebas automatizadas:} Esenciales para detectar regresiones tempranamente
    \item \textbf{Docker:} Simplifica enormemente el despliegue y la consistencia entre entornos
    \item \textbf{Documentación:} Fundamental para mantenimiento y escalabilidad del proyecto
\end{enumerate}

% ============================================
% TRABAJO FUTURO
% ============================================
\section{Trabajo Futuro}

\subsection{Mejoras de Seguridad}

\begin{itemize}
    \item \textbf{Autenticación multi-factor (MFA):} Implementar 2FA con TOTP
    \item \textbf{Liveness detection:} Prevenir spoofing en reconocimiento facial
    \item \textbf{Auditoría:} Sistema de logs de auditoría para acciones críticas
    \item \textbf{Rate limiting avanzado:} Límites por usuario y por IP
    \item \textbf{Web Application Firewall:} Protección adicional contra ataques
\end{itemize}

\subsection{Escalabilidad}

\begin{itemize}
    \item \textbf{Kubernetes:} Migración a orquestación con Kubernetes
    \item \textbf{Load balancing:} Múltiples instancias de cada servicio
    \item \textbf{Redis:} Cache distribuido para mejor rendimiento
    \item \textbf{CDN:} Distribución de contenido estático
    \item \textbf{Microservicios adicionales:} Separar más funcionalidades
\end{itemize}

\subsection{Funcionalidades Nuevas}

\begin{itemize}
    \item \textbf{Recomendaciones con IA:} Sistema de recomendación de destinos
    \item \textbf{Integración con blockchain:} Verificación de identidad descentralizada
    \item \textbf{Aplicación móvil:} Apps nativas iOS y Android
    \item \textbf{Realidad aumentada:} Visualización AR de destinos
    \item \textbf{Chatbot:} Asistente virtual para planificación de viajes
\end{itemize}

% ============================================
% CONCLUSIONES
% ============================================
\section{Conclusiones}

TravelBrain demuestra exitosamente la implementación de un sistema complejo de planificación de viajes que integra múltiples tecnologías modernas con un enfoque prioritario en la seguridad. Las principales contribuciones de este proyecto son:

\begin{enumerate}
    \item \textbf{Arquitectura de microservicios robusta:} La separación en servicios independientes facilita el escalamiento, mantenimiento y despliegue independiente de cada componente, demostrando las mejores prácticas de arquitectura moderna.

    \item \textbf{Seguridad multicapa:} La implementación de JWT, OAuth 2.0, reconocimiento facial, HTTPS, CORS, y encriptación de contraseñas proporciona múltiples capas de protección, cumpliendo con los estándares de desarrollo seguro.

    \item \textbf{Autenticación biométrica:} La integración de reconocimiento facial con DeepFace y TensorFlow representa una implementación avanzada de autenticación biométrica, alcanzando precisión superior al 90\%.

    \item \textbf{Sistema administrativo completo:} El panel de administración con RBAC, gestión de estados de usuarios y estadísticas en tiempo real demuestra control granular sobre la plataforma.

    \item \textbf{Cobertura exhaustiva de pruebas:} Las 9 pruebas E2E con Cypress, junto con pruebas unitarias e de integración, garantizan la calidad y confiabilidad del sistema.

    \item \textbf{Despliegue en producción:} El despliegue completo con Docker, Docker Compose, HTTPS, y certificados SSL/TLS de Let's Encrypt demuestra capacidades DevOps profesionales.

    \item \textbf{Integración de servicios externos:} La integración exitosa con OpenWeather, Mapbox y Google OAuth muestra habilidades de trabajo con APIs de terceros de manera segura.
\end{enumerate}

El proyecto TravelBrain cumple con todos los objetivos planteados inicialmente y sirve como referencia de implementación de desarrollo seguro en aplicaciones web modernas. La documentación exhaustiva, el código limpio y modular, y las pruebas automatizadas aseguran que el sistema sea mantenible y escalable a largo plazo.

Las lecciones aprendidas durante el desarrollo, especialmente en la coordinación de microservicios, implementación de seguridad multicapa, y despliegue con Docker, proporcionan conocimientos valiosos aplicables en proyectos profesionales.

El sistema está preparado para evolucionar con las mejoras propuestas en trabajo futuro, incluyendo la migración a Kubernetes para mayor escalabilidad, implementación de autenticación multi-factor, y adición de nuevas funcionalidades basadas en inteligencia artificial.

% ============================================
% AGRADECIMIENTOS
% ============================================
\section*{Agradecimientos}

Agradecemos al Ing. Angel Cudco por su guía y enseñanzas en la asignatura de Desarrollo de Software Seguro, que fueron fundamentales para la implementación de las medidas de seguridad de este proyecto. También a la Universidad de las Fuerzas Armadas ESPE por proporcionar el entorno académico y los recursos necesarios para el desarrollo exitoso de este trabajo.

% ============================================
% REFERENCIAS
% ============================================
\begin{thebibliography}{99}

\bibitem{jwt}
Auth0, ``Introduction to JSON Web Tokens,'' \url{https://jwt.io/introduction}, 2024.

\bibitem{oauth}
OAuth, ``OAuth 2.0,'' \url{https://oauth.net/2/}, 2024.

\bibitem{deepface}
S. I. Serengil and A. Ozpinar, ``HyperExtended LightFace: A Facial Attribute Analysis Framework,'' in \textit{2021 International Conference on Engineering and Emerging Technologies (ICEET)}, pp. 1-4, 2021.

\bibitem{bcrypt}
N. Provos and D. Mazières, ``A Future-Adaptable Password Scheme,'' in \textit{Proceedings of the 1999 USENIX Annual Technical Conference}, pp. 81-92, 1999.

\bibitem{docker}
Docker Inc., ``Docker Documentation,'' \url{https://docs.docker.com/}, 2024.

\bibitem{microservices}
J. Lewis and M. Fowler, ``Microservices: a definition of this new architectural term,'' \url{https://martinfowler.com/articles/microservices.html}, 2014.

\bibitem{nodejs}
Node.js Foundation, ``Node.js Documentation,'' \url{https://nodejs.org/en/docs/}, 2024.

\bibitem{react}
Meta Platforms, Inc., ``React Documentation,'' \url{https://react.dev/}, 2024.

\bibitem{mongodb}
MongoDB Inc., ``MongoDB Manual,'' \url{https://www.mongodb.com/docs/}, 2024.

\bibitem{nginx}
F5 Networks, Inc., ``NGINX Documentation,'' \url{https://nginx.org/en/docs/}, 2024.

\bibitem{letsencrypt}
Internet Security Research Group, ``Let's Encrypt Documentation,'' \url{https://letsencrypt.org/docs/}, 2024.

\bibitem{cypress}
Cypress.io, ``Cypress Documentation,'' \url{https://docs.cypress.io/}, 2024.

\bibitem{owasp}
OWASP Foundation, ``OWASP Top Ten,'' \url{https://owasp.org/www-project-top-ten/}, 2024.

\bibitem{restapi}
R. T. Fielding, ``Architectural Styles and the Design of Network-based Software Architectures,'' Doctoral dissertation, University of California, Irvine, 2000.

\bibitem{cors}
W3C, ``Cross-Origin Resource Sharing,'' \url{https://www.w3.org/TR/cors/}, 2024.

\bibitem{tensorflow}
Google, ``TensorFlow Documentation,'' \url{https://www.tensorflow.org/}, 2024.

\bibitem{fastapi}
S. Ramírez, ``FastAPI Documentation,'' \url{https://fastapi.tiangolo.com/}, 2024.

\bibitem{passport}
Jared Hanson, ``Passport.js Documentation,'' \url{http://www.passportjs.org/docs/}, 2024.

\bibitem{express}
Express.js, ``Express API Reference,'' \url{https://expressjs.com/en/api.html}, 2024.

\bibitem{vite}
Evan You, ``Vite Documentation,'' \url{https://vitejs.dev/}, 2024.

\end{thebibliography}

% ============================================
% APÉNDICES
% ============================================
\appendix

\section{Estructura Completa del Proyecto}

\begin{lstlisting}[language=bash, caption={Estructura de directorios}]
TravelBrain/
|-- frontend-react/
|   |-- src/
|   |   |-- components/
|   |   |-- pages/
|   |   |-- context/
|   |   |-- utils/
|   |   +-- App.jsx
|   |-- cypress/
|   |   +-- e2e/
|   +-- package.json
|-- backend-project/
|   |-- src/
|   |   |-- controllers/
|   |   |-- models/
|   |   |-- routes/
|   |   |-- middlewares/
|   |   |-- utils/
|   |   +-- server.js
|   |-- tests/
|   +-- package.json
|-- business-rules-backend/
|   |-- src/
|   |   |-- controllers/
|   |   |-- validators/
|   |   |-- services/
|   |   +-- server.js
|   +-- package.json
|-- facial-recognition-service/
|   |-- src/
|   |   |-- api/
|   |   |-- models/
|   |   |-- services/
|   |   +-- app.py
|   +-- requirements.txt
|-- nginx/
|   |-- nginx.conf
|   +-- Dockerfile
|-- certbot/
|   |-- conf/
|   +-- www/
+-- docker-compose.yml
\end{lstlisting}

\section{Variables de Entorno}

\begin{lstlisting}[caption={.env (ejemplo)}]
# Backend API
NODE_ENV=production
PORT=3004
MONGODB_URI=mongodb+srv://...
JWT_SECRET=your-secret-key-here
JWT_EXPIRES_IN=7d

# Google OAuth
GOOGLE_CLIENT_ID=your-client-id
GOOGLE_CLIENT_SECRET=your-client-secret
GOOGLE_CALLBACK_URL=https://travelbrain.ddns.net/api/auth/google/callback

# APIs externas
OPENWEATHER_API_KEY=your-api-key
MAPBOX_TOKEN=your-mapbox-token

# CORS
CORS_ORIGINS=https://travelbrain.ddns.net

# Business Rules API
BR_PORT=3005

# Facial Recognition Service
FACE_PORT=8000
FACE_DETECTION_BACKEND=retinaface
FACE_RECOGNITION_MODEL=Facenet512
SIMILARITY_THRESHOLD=0.6
\end{lstlisting}

\section{Comandos de Despliegue}

\begin{lstlisting}[language=bash, caption={Comandos útiles}]
# Iniciar todos los servicios
docker-compose up -d --build

# Ver logs
docker-compose logs -f

# Detener servicios
docker-compose down

# Reiniciar un servicio específico
docker-compose restart backend

# Obtener certificados SSL
sh init-letsencrypt.sh

# Ver estado de contenedores
docker-compose ps

# Acceder a un contenedor
docker exec -it travelbrain-backend sh

# Limpiar volúmenes
docker-compose down -v
\end{lstlisting}

\end{document}
